{"fonts":[],"slides":[{"sid":1,"startTime":0,"duration":206,"name":"Flat-Shading in OpenGL","page":1,"videos":[],"animations":[],"images":[],"quizzes":[{"transformations":[],"qid":106,"id":106,"startTime":0,"duration":206,"position":{"x":200,"y":400},"height":400,"width":300,"questionContent":"0 = ?","correctAnswer":"0","wrongAnswers":["1","2","3"],"tip":"Because 0 = 0","zIndex":2}],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":100,"id":100,"startTime":0,"duration":206,"content":"<p>Im Core-Profile muss jeder Vertex einen Normalenvektor aufweisen falls Normalen gegeben werden<br/>  • Grund: VAO-Datenstruktur</p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":101,"id":101,"startTime":0,"duration":206,"content":"<p>Auswertung der <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Beleuchtung im Vertex-Shader</span></p>\n","position":{"x":150,"y":320},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":103,"id":103,"startTime":0,"duration":206,"content":"<p>Übergabe der Farbwerte mit <strong><code class=\"language-glsl\"><span class=\"hljs-keyword\">flat</span> <span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec4</span> vColor;</code></strong><br/>  • Rasterizer nimmt <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">keine Interpolation</span> vor</p>\n","position":{"x":150,"y":400},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":104,"id":104,"startTime":0,"duration":206,"content":"<p>Im <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Fragment-Shader wird nur die Farbe dem Pixel</span> zugewiesen</p>\n","position":{"x":150,"y":530},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":105,"id":105,"startTime":0,"duration":206,"content":"<p>D.h. jedoch, dass Flat-Shading im Core-Profile trotzdem <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">für jeden Vertex eine Beleuchtungsberechnung</span> durchführen muss</p>\n","position":{"x":150,"y":600},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":2,"startTime":206,"duration":44,"name":"Smooth-Shading in OpenGL","page":2,"videos":[],"animations":[],"images":[],"quizzes":[],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":200,"id":200,"startTime":206,"duration":44,"content":"<p>Auswertung der Beleuchtung im Vertex-Shader</p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":201,"id":201,"startTime":206,"duration":44,"content":"<p>Übergabe der Farbwerte mit <strong><code class=\"language-glsl\"><span class=\"hljs-keyword\">smooth</span> <span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec4</span> vColor;</code></strong><br/> →  Rasterizer nimmt Interpolation vor ( <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">smooth ist default in GLSL</span> )</p>\n","position":{"x":150,"y":270},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":202,"id":202,"startTime":206,"duration":44,"content":"<p>Im Fragment-Shader nur Zuweisung Farbe -&gt; Pixel</p>\n","position":{"x":150,"y":390},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":3,"startTime":250,"duration":176,"name":"Phong-Shading in OpenGL","page":3,"videos":[],"animations":[],"images":[],"quizzes":[],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":300,"id":300,"startTime":250,"duration":176,"content":"<p>Übergabe der <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">transformierten</span> Normalen und der transformierten Positionen der Vertices vom Vertex-Shader zum Fragment-Shader (<span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">meist in View-Koordinaten</span>)</p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":301,"id":301,"startTime":250,"duration":176,"content":"<pre><code class=\"hljs language-glsl\"><span class=\"hljs-keyword\">smooth</span> <span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec3</span> Normal;\n<span class=\"hljs-keyword\">smooth</span> <span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec3</span> Position;\n</code></pre>\n","position":{"x":200,"y":300},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":302,"id":302,"startTime":250,"duration":176,"content":"<p>Auswertung der Beleuchtung im Fragment-Shader</p>\n","position":{"x":150,"y":500},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":4,"startTime":426,"duration":285,"name":"Beispiel Phong-Shading mit Blinn-Beleuchtung","page":4,"videos":[],"animations":[],"images":[],"quizzes":[],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":401,"id":401,"startTime":426,"duration":285,"content":"<p><strong>Im <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Vertex-Shader</span></strong></p>\n","position":{"x":120,"y":150},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":402,"id":402,"startTime":426,"duration":285,"content":"<ol>\n<li>Berechnung von <code class=\"language-glsl\"><span class=\"hljs-built_in\">gl_Position</span></code><br/>\n<span style='font-size: 28px;'>• built-in variable, die die Vertices aufbereitet für Clipping, <br/>Culling, etc.</span></li>\n<li>Berechnung der für die Beleuchtung <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">im Fragment-<br>Shader notwendigen</span> Parameter:\n<br/><br/>\n<strong>Position</strong>\n<br/>\n<span style='font-size: 28px;'> • Transformiert jedes Vertex <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">in View-Space transformiert</span></span>\n<br/>\n<strong>Normal</strong>\n<br/>\n<span style='font-size: 28px;'> • Transformiert Normalen mit der Normal-Matrix (<span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">inverse,<br/>\ntransponierte 3x3 ModelView-Matrix</span>)</span></li>\n</ol>\n","position":{"x":120,"y":200},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":403,"id":403,"startTime":426,"duration":285,"content":"<p>Berechnung der <span class=\"md-colorify md-colorify--red\" style=\"color: red;\">NormalMatrix außerhalb des Shaders</span>:</p>\n","position":{"x":120,"y":780},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":404,"id":404,"startTime":426,"duration":285,"content":"<pre><code class=\"hljs language-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;glm/gtx/inverse_transpose.hpp&gt;</span></span>\ngl_NormalMatrix =\nglm::<span class=\"hljs-built_in\">inverseTranspose</span>(glm::<span class=\"hljs-built_in\">mat3</span>(gl_ModelViewMatrix));\n</code></pre>\n","position":{"x":120,"y":830},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":405,"id":405,"startTime":426,"duration":285,"content":"<pre><code class=\"hljs language-glsl\"><span class=\"hljs-comment\">//Eingabe-Werte pro Vertex </span>\n<span class=\"hljs-keyword\">in</span> <span class=\"hljs-type\">vec4</span> vVertex;    <span class=\"hljs-comment\">//Vertex-Position in Objektkoordinaten</span>\n<span class=\"hljs-keyword\">in</span> <span class=\"hljs-type\">vec3</span> vNormal;    <span class=\"hljs-comment\">//Normalen-Vektor in Objektkoordinaten</span>\n\n\n<span class=\"hljs-comment\">//Uniform-Eingabe-Werte </span>\n<span class=\"hljs-keyword\">uniform</span> mat4MV;        <span class=\"hljs-comment\">//ModelView-Matrix </span>\n<span class=\"hljs-keyword\">uniform</span> mat4MVP;       <span class=\"hljs-comment\">//ModelViewProjection-Matrix </span>\n<span class=\"hljs-keyword\">uniform</span> <span class=\"hljs-type\">mat3</span> NormalM;  <span class=\"hljs-comment\">//Normalen-Matrix</span>\n\n\n<span class=\"hljs-comment\">//Ausgabe-Werte smooth </span>\n<span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec3</span> Position;   <span class=\"hljs-comment\">//Vertex-Position in Augenpunktskoordinaten  </span>\n<span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec3</span> Normal;     <span class=\"hljs-comment\">//Normalen-Vektor in Augenpunktskoordinaten </span>\n\n\n<span class=\"hljs-type\">void</span> main(<span class=\"hljs-type\">void</span>)\n{\n<span class=\"hljs-comment\">//Vertex aus Objekt-in Projektionskoordinaten </span>\n<span class=\"hljs-built_in\">gl_Position</span> = MVP * vVertex;\n<span class=\"hljs-comment\">//Verter aus Objekt-in Augenpunktskoordinaten </span>\n<span class=\"hljs-type\">vec4</span> Pos = MW * vVertex; \nPosition = Pos.xyz / Pos.w;\n<span class=\"hljs-comment\">//Vertex-Normale aus Objekt-in Augenpunktskoordinaten </span>\nNormal = <span class=\"hljs-built_in\">normalize</span>(NormalM * vNormal);\n}\n</code></pre>\n","position":{"x":930,"y":150},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":5,"startTime":711,"duration":116,"name":"Normal-Matrix","page":5,"videos":[{"transformations":[],"vid":505,"id":505,"startTime":821,"duration":6,"path":"warum.mp4","isYouTube":false,"isOnline":false,"position":{"x":100,"y":150},"height":828,"width":1472,"zIndex":1}],"animations":[],"images":[{"transformations":[],"iid":502,"id":502,"startTime":711,"duration":109,"path":"https://i.ibb.co/TrzTc9j/3f82a9a9-2a07-4e37-cebb-8396ab97a04c.png","isOnline":true,"position":{"x":400,"y":650},"height":0,"width":0,"zIndex":1},{"transformations":[],"iid":503,"id":503,"startTime":711,"duration":109,"path":"https://i.ibb.co/LJ4bkCJ/d500b649-6d74-41a7-a667-49cb4bb922a6.png","isOnline":true,"position":{"x":800,"y":600},"height":0,"width":0,"zIndex":1}],"quizzes":[],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":500,"id":500,"startTime":711,"duration":109,"content":"<p>Normalen können nicht wie Positionen transformiert werden<br/>\n • <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Rotationen</span> sind kein Problem</br>\n • <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Translationen</span> sind kein Problem, wenn 𝑤 = 0 (dann hat die 4. Spalte der Matrix keinen Effekt)<br/>\n • alle anderen Transformationen sind ein Problem</p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":501,"id":501,"startTime":711,"duration":109,"content":"<p>Anstelle der Matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> wird <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy=\"false\">)</mo><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">N = (M^{-1})^{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> verwendet<br/>\n • bei Rotationen ist <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>M</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">M^{-1} = M^{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span></p>\n","position":{"x":150,"y":430},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":504,"id":504,"startTime":711,"duration":109,"content":"<p><a href=\"http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/\">http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/</a></p>\n","position":{"x":700,"y":950},"fontSize":30,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":6,"startTime":828,"duration":150,"name":"Beispiel Phong-Shading mit Blinn-Beleuchtung - 1","page":6,"videos":[],"animations":[],"images":[],"quizzes":[],"customs":[],"graphics":[],"texts":[{"transformations":[],"tid":601,"id":601,"startTime":828,"duration":150,"content":"<p>Im <strong><span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Fragment-Shader</span></strong></p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":602,"id":602,"startTime":828,"duration":150,"content":"<p><span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Vertices</span> mit <strong>Position</strong> und <strong>Normal</strong>\n<br/>annehmen</p>\n","position":{"x":150,"y":260},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":603,"id":603,"startTime":828,"duration":150,"content":"<p><span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Parameter der Lichtkomponenten</span>\n<br/>entgegennehmen\n<br/> • <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Material</span>-Eigenschaften\n</br> • <span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Lichtquellen</span>-Eigenschaften</p>\n","position":{"x":150,"y":390},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":604,"id":604,"startTime":828,"duration":150,"content":"<p>Berechnung der Fragment-Farbe\n<br/> • FragColor</p>\n","position":{"x":150,"y":640},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":605,"id":605,"startTime":828,"duration":150,"content":"<p>Bei älteren GLSL Versionen<br/>\nauf Uniform-Struct verzichten\n<br/> • Einzelne Uniforms übergeben</p>\n","position":{"x":150,"y":770},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":606,"id":606,"startTime":828,"duration":150,"content":"<pre><code class=\"hljs language-glsl\"><span class=\"hljs-comment\">//linear interpolierte Eingabe-Werte pro Fragment </span>\n<span class=\"hljs-keyword\">in</span> <span class=\"hljs-type\">vec3</span> Position;      <span class=\"hljs-comment\">//Fragment-Position in 3D </span>\n<span class=\"hljs-keyword\">in</span> <span class=\"hljs-type\">vec3</span> Normal;        <span class=\"hljs-comment\">//Normalen-Vektor</span>\n\n<span class=\"hljs-comment\">//Uniform-Block für Material-Eigenschaften </span>\n<span class=\"hljs-keyword\">uniform</span> MaterialParams {\n<span class=\"hljs-type\">vec4</span> emission; \n<span class=\"hljs-type\">vec4</span> ambient;\n<span class=\"hljs-type\">vec4</span> diffuse; \n<span class=\"hljs-type\">vec4</span> specular; \n<span class=\"hljs-type\">float</span> shininess; } Material;\n\n<span class=\"hljs-comment\">//Uniform-Block fir Lichtquellen-Eigenschaften </span>\n<span class=\"hljs-keyword\">uniform</span> LightParams {\n<span class=\"hljs-type\">vec4</span> position; \n<span class=\"hljs-type\">vec4</span> ambient;\n<span class=\"hljs-type\">vec4</span> diffuse; \n<span class=\"hljs-type\">vec4</span> specular; \n<span class=\"hljs-type\">vec3</span> halfVector } LightSource;\n\n<span class=\"hljs-comment\">//Ausgabe-Wert:Farbe des Fragments </span>\n<span class=\"hljs-keyword\">out</span> <span class=\"hljs-type\">vec4</span> FragColor;\n</code></pre>\n","position":{"x":700,"y":150},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]},{"sid":7,"startTime":978,"duration":801,"name":"Beispiel Phong-Shading mit Blinn-Beleuchtung - 2","page":7,"videos":[],"animations":[],"images":[{"transformations":[],"iid":703,"id":703,"startTime":978,"duration":222,"path":"https://i.ibb.co/cvfb5Xn/5205afb0-b994-4b0e-85af-1292088003d3.png","isOnline":true,"position":{"x":30,"y":420},"height":165,"width":800,"zIndex":1}],"quizzes":[],"customs":[{"transformations":[],"path":"C:\\Users\\Chang\\Desktop\\example\\teapot.html","cid":706,"id":706,"type":"HTML","startTime":1200,"duration":579,"position":{"x":50,"y":180},"zIndex":5,"htmlContent":"<div class='customComponent'><script src=\"https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.3.2/gl-matrix-min.js\" integrity=\"sha512-fQ4Od/Hz+3oZYpqM4Mrg8t12JPTWwic/qw1ULWyMRwXRE+LUvYFjxokHbUriaMn1tOawSx49EQBIqDuqDN1vog==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\r\n\r\n\r\n<script>\r\n\tsetTimeout({}, 3000);\r\n\tvar vertexShaderText =\r\n\t\t`\r\nprecision mediump float;\r\n\r\nuniform mat4 mWorld;\r\nuniform mat4 mView;\r\nuniform mat4 mProj;\r\nuniform mat3 mNormal;\r\nuniform vec3 lightDir;\r\nattribute vec3 vPosition;\r\nattribute vec3 vNormal;\r\nattribute vec4 vColor;\r\nvarying vec3 fNormal;\r\nvarying vec3 fLightDir;\r\nvarying vec4 fColor;\r\n\r\nvoid main()\r\n{\r\n  fNormal = mNormal * vNormal;\r\n  fLightDir = (mView * vec4(lightDir, 0.0)).xyz;\r\n  fColor = vColor;\r\n  gl_Position = mProj * mView * mWorld * vec4(vPosition, 1.0);\r\n}\r\n`;\r\n\r\n\tvar fragmentShaderText =\r\n\t\t`\r\nprecision mediump float;\r\n\r\nuniform vec3 cAmbient;\r\nuniform vec3 cDiffuse;\r\nuniform vec3 cSpecular;\r\nuniform float alpha;\r\nvarying vec3 fNormal;\r\nvarying vec3 fLightDir;\r\nvarying vec4 fColor;\r\nvoid main()\r\n{\r\n  vec3 lightDir = normalize(fLightDir);\r\n  vec3 normalDir = normalize(fNormal);\r\n  vec3 eyeDir = vec3(0.0, 0.0, 1.0);\r\n  vec3 light = cAmbient;\r\n  light += cDiffuse * max(dot(normalDir, lightDir), 0.0);\r\n  light += cSpecular * pow(max(dot(reflect(-lightDir, normalDir), eyeDir), 0.0), alpha);\r\n  gl_FragColor =  vec4(fColor.rgb * light, fColor.a);\r\n}\r\n`;\r\n\r\n\t// This is just a simple demonstration. Wavefront OBJ is not fully supported!\r\n\t// See https://en.wikipedia.org/wiki/Wavefront_.obj_file for more information.\r\n\tasync function fetchModel(location) {\r\n\r\n\t\t// fetch is explained at https://www.youtube.com/watch?v=tc8DU14qX6I.\r\n\t\tvar response = await fetch(location);\r\n\t\tvar txt = await response.text();\r\n\t\t// console.log(txt);\r\n\t\t// var txt = \"\"\r\n\t\tvar lines = txt.split(/\\r*\\n/);\r\n\r\n\t\tvar v = [];\r\n\t\tvar vt = [];\r\n\t\tvar vn = [];\r\n\t\tvar vbo = [];\r\n\r\n\t\tfor (line of lines) {\r\n\t\t\tvar data = line.trim().split(/\\s+/);\r\n\t\t\tvar type = data.shift();\r\n\t\t\tif (type == 'v') {\r\n\t\t\t\tv.push(data.map(x => { return parseFloat(x) }));\r\n\t\t\t}\r\n\t\t\telse if (type == 'vt') {\r\n\t\t\t\tvt.push(data.map(x => { return parseFloat(x) }));\r\n\t\t\t}\r\n\t\t\telse if (type == 'vn') {\r\n\t\t\t\tvn.push(data.map(x => { return parseFloat(x) }));\r\n\t\t\t}\r\n\t\t\telse if (type == 'f') {\r\n\t\t\t\tfor (fp of data) {\r\n\t\t\t\t\tvar idx = fp.split('/').map(x => { return parseInt(x) });\r\n\t\t\t\t\tv[idx[0] - 1].forEach(x => { vbo.push(x) });\r\n\t\t\t\t\tvt[idx[1] - 1].forEach(x => { vbo.push(x) });\r\n\t\t\t\t\tvn[idx[2] - 1].forEach(x => { vbo.push(x) });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn vbo;\r\n\t};\r\n\r\n\tfunction createShaderProgram(gl, vertexShaderText, fragmentShaderText) {\r\n\t\tvar vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n\t\tvar fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n\r\n\t\tgl.shaderSource(vertexShader, vertexShaderText);\r\n\t\tgl.shaderSource(fragmentShader, fragmentShaderText);\r\n\r\n\t\tgl.compileShader(vertexShader);\r\n\t\tif (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n\t\t\tconsole.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tgl.compileShader(fragmentShader);\r\n\t\tif (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n\t\t\tconsole.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar program = gl.createProgram();\r\n\t\tgl.attachShader(program, vertexShader);\r\n\t\tgl.attachShader(program, fragmentShader);\r\n\t\tgl.linkProgram(program);\r\n\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n\t\t\tconsole.error('ERROR linking program!', gl.getProgramInfoLog(program));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tgl.validateProgram(program);\r\n\t\tif (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n\t\t\tconsole.error('ERROR validating program!', gl.getProgramInfoLog(program));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn program;\r\n\t}\r\n\r\n\tasync function createTeapot(gl) {\r\n\t\tvar teapot = {};\r\n\r\n\t\tvar vertices = await fetchModel('https://a.tmp.ninja/XeHKgKau.obj');\r\n\t\t// console.log(vertices);\r\n\t\tteapot.vertexBufferObject = gl.createBuffer();\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, teapot.vertexBufferObject);\r\n\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n\t\tteapot.draw = function (program) {\r\n\t\t\tvar cAmbientUniformLocation = gl.getUniformLocation(program, 'cAmbient');\r\n\t\t\tgl.uniform3f(cAmbientUniformLocation, 0.23, 0.09, 0.03);\r\n\r\n\t\t\tvar cDiffuseUniformLocation = gl.getUniformLocation(program, 'cDiffuse');\r\n\t\t\tgl.uniform3f(cDiffuseUniformLocation, 0.55, 0.21, 0.07);\r\n\r\n\t\t\tvar cSpecularUniformLocation = gl.getUniformLocation(program, 'cSpecular');\r\n\t\t\tgl.uniform3f(cSpecularUniformLocation, 0.58, 0.22, 0.07);\r\n\r\n\t\t\tvar alphaUniformLocation = gl.getUniformLocation(program, 'alpha');\r\n\t\t\tgl.uniform1f(alphaUniformLocation, 51.2);\r\n\r\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferObject);\r\n\r\n\t\t\tvar positionAttribLocation = gl.getAttribLocation(program, 'vPosition');\r\n\t\t\tgl.vertexAttribPointer(\r\n\t\t\t\tpositionAttribLocation, // Attribute location\r\n\t\t\t\t3, // Number of elements per attribute\r\n\t\t\t\tgl.FLOAT, // Type of elements\r\n\t\t\t\tgl.FALSE,\r\n\t\t\t\t8 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex\r\n\t\t\t\t0 // Offset from the beginning of a single vertex to this attribute\r\n\t\t\t);\r\n\t\t\tgl.enableVertexAttribArray(positionAttribLocation);\r\n\r\n\t\t\tvar normalAttribLocation = gl.getAttribLocation(program, 'vNormal');\r\n\t\t\tgl.vertexAttribPointer(\r\n\t\t\t\tnormalAttribLocation, // Attribute location\r\n\t\t\t\t3, // Number of elements per attribute\r\n\t\t\t\tgl.FLOAT, // Type of elements\r\n\t\t\t\tgl.FALSE,\r\n\t\t\t\t8 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex\r\n\t\t\t\t5 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\r\n\t\t\t);\r\n\t\t\tgl.enableVertexAttribArray(normalAttribLocation);\r\n\r\n\t\t\tvar colorAttribLocation = gl.getAttribLocation(program, 'vColor');\r\n\t\t\tgl.vertexAttrib4f(colorAttribLocation, 1.0, 1.0, 1.0, 1.0);\r\n\r\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, vertices.length / 8);\r\n\r\n\t\t\tgl.disableVertexAttribArray(positionAttribLocation);\r\n\t\t\tgl.disableVertexAttribArray(normalAttribLocation);\r\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\t\t}\r\n\t\treturn teapot;\r\n\t}\r\n\r\n\tasync function InitDemo() {\r\n\r\n\t\t// Get WebGL context\r\n\t\tconsole.log('Getting WebGL context ...');\r\n\t\tvar canvas = document.getElementById('cg1-canvas');\r\n\t\tvar gl = canvas.getContext('webgl');\r\n\t\tif (!gl) {\r\n\t\t\tconsole.log('WebGL not supported, falling back on experimental-webgl');\r\n\t\t\tgl = canvas.getContext('experimental-webgl');\r\n\t\t}\r\n\t\tif (!gl) {\r\n\t\t\tconsole.error('Your browser does not support WebGL');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Create shaders\r\n\t\tconsole.log('Creating shaders ...');\r\n\t\tvar program = createShaderProgram(gl, vertexShaderText, fragmentShaderText);\r\n\t\tif (!program) {\r\n\t\t\tconsole.error('Cannot run without shader program!');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Create teapot object\r\n\t\tconsole.log('Creating teapot object ...');\r\n\t\tvar teapot = await createTeapot(gl);\r\n\t\t// console.log(teapot);\r\n\r\n\t\t// Configure OpenGL state machine\r\n\t\tgl.useProgram(program);\r\n\r\n\t\tgl.clearColor(0.75, 0.85, 0.8, 1.0);\r\n\t\tgl.enable(gl.DEPTH_TEST);\r\n\r\n\t\tvar lightDirUniformLocation = gl.getUniformLocation(program, 'lightDir');\r\n\t\tgl.uniform3f(lightDirUniformLocation, 0.0, 1.0, 0.0);\r\n\t\t// console.log(\"CHECKPOINT\");\r\n\r\n\t\tvar projMatrix = new Float32Array(16);\r\n\t\t// console.log(canvas.clientWidth / canvas.clientHeight, 0.1, 1000.0);\r\n\t\tmat4.perspective(projMatrix, glMatrix.toRadian(45), canvas.clientWidth / canvas.clientHeight, 0.1, 1000.0);\r\n\t\t// console.log('mProj');\r\n\t\tvar matProjUniformLocation = gl.getUniformLocation(program, 'mProj');\r\n\t\tgl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);\r\n\t\t// console.log(\"CHECKPOINT2\");\r\n\r\n\t\t// Main render loop\r\n\t\tvar matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');\r\n\t\tvar matViewUniformLocation = gl.getUniformLocation(program, 'mView');\r\n\t\tvar matNormUniformLocation = gl.getUniformLocation(program, 'mNormal');\r\n\t\t// console.log(\"CHECKPOINT3\");\r\n\r\n\t\tvar angle = 0;\r\n\t\tvar worldMatrix = new Float32Array(16);\r\n\t\tvar viewMatrix = new Float32Array(16);\r\n\t\tvar normalMatrix = new Float32Array(9);\r\n\t\tvar tmpMatrix = new Float32Array(16);\r\n\t\t// console.log(\"WHATTTT\");\r\n\t\tvar loop = function () {\r\n\t\t\tgl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);\r\n\r\n\t\t\tangle = performance.now() / 1000 / 6 * 2 * Math.PI;\r\n\r\n\t\t\tmat4.lookAt(viewMatrix, [0, 3, 7], [0, 0, 0], [0, 1, 0]);\r\n\t\t\tmat4.rotate(viewMatrix, viewMatrix, angle / 4, [0, 1, 0]);\r\n\t\t\tgl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);\r\n\r\n\t\t\tmat4.identity(worldMatrix);\r\n\t\t\tgl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);\r\n\r\n\t\t\tmat4.multiply(tmpMatrix, viewMatrix, worldMatrix);\r\n\t\t\t//mat4.identity(tmpMatrix);\r\n\t\t\tmat3.normalFromMat4(normalMatrix, tmpMatrix);\r\n\t\t\tgl.uniformMatrix3fv(matNormUniformLocation, gl.FALSE, normalMatrix);\r\n\r\n\t\t\tteapot.draw(program);\r\n\r\n\t\t\trequestAnimationFrame(loop);\r\n\t\t};\r\n\r\n\t\tconsole.log('Entering rendering loop ...')\r\n\t\trequestAnimationFrame(loop);\r\n\t};\r\n\r\n\tInitDemo();\r\n\t\t// window.onload = InitDemo;\r\n</script>\r\n\r\n\r\n\r\n<canvas id=\"cg1-canvas\" width=\"1024\" height=\"768\"></canvas></div>","scriptContent":""},{"transformations":[],"path":"C:\\Users\\Chang\\Desktop\\example\\test.js","cid":707,"id":707,"type":"JS","startTime":978,"duration":222,"position":{"x":0,"y":0},"htmlContent":"","scriptContent":"console.log(\"Here is Test.js\");"},{"transformations":[],"path":"C:\\Users\\Chang\\Desktop\\example\\editor.html","cid":708,"id":708,"type":"HTML","startTime":1200,"duration":579,"position":{"x":1050,"y":150},"zIndex":5,"htmlContent":"<div class='customComponent'><!-- <script type=\"module\" src=\"https://vanillawc.github.io/wc-monaco-editor/index.min.js\"></script> -->\r\n<script type=\"module\" src=\"https://cdn.jsdelivr.net/npm/@vanillawc/wc-monaco-editor@1.10.14/index.min.js\"></script>\r\n<wc-monaco-editor language=\"javascript\" src=\"https://a.tmp.ninja/LdLUdOvz.js\" font-size=\"22px\" style=\"width:800px; height:800px; margin: 25px; border: 5px solid #888; box-shadow: 5px 10px 18px #888888;\">\r\n</wc-monaco-editor></div>","scriptContent":""}],"graphics":[],"texts":[{"transformations":[],"tid":701,"id":701,"startTime":978,"duration":222,"content":"<p>Im <strong><span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Fragment-Shader</span></strong></p>\n","position":{"x":150,"y":180},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":702,"id":702,"startTime":978,"duration":222,"content":"<p><span class=\"md-colorify md-colorify--#DC3C0B\" style=\"color: #DC3C0B;\">Berechnung der Fragment-Farbe</span> durch die<br/>\nangewandte Beleuchtung</p>\n","position":{"x":150,"y":260},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":704,"id":704,"startTime":978,"duration":222,"content":"<p>GLSL bietet hierfür entsprechende<br/>\nmathematische Funktionen an</p>\n","position":{"x":150,"y":650},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1},{"transformations":[],"tid":705,"id":705,"startTime":978,"duration":222,"content":"<pre><code class=\"hljs language-glsl\"><span class=\"hljs-type\">void</span> main(<span class=\"hljs-type\">void</span>) \n{\n<span class=\"hljs-comment\">//Berechnung des Phong-Blinn-Beleuchtungsmodells </span>\n<span class=\"hljs-type\">vec3</span> N = <span class=\"hljs-built_in\">normalize</span>(Normal); \n<span class=\"hljs-type\">vec4</span> emissiv = Material.emission; \n<span class=\"hljs-type\">vec4</span> ambient = Material.ambient * LightSource.ambient; \n<span class=\"hljs-type\">vec3</span> L = <span class=\"hljs-type\">vec3</span>(<span class=\"hljs-number\">0.0</span>);    <span class=\"hljs-comment\">//alle drei Komponenten werden auf 0.0 gesetzt </span>\n<span class=\"hljs-type\">vec3</span> H = <span class=\"hljs-type\">vec3</span>(<span class=\"hljs-number\">0.0</span>); \n<span class=\"hljs-keyword\">if</span>(LightSource.position.w == <span class=\"hljs-number\">0</span>) {\n    L = <span class=\"hljs-built_in\">normalize</span>(<span class=\"hljs-type\">vec3</span>(LightSource.position)); \n    H = <span class=\"hljs-built_in\">normalize</span>(LightSource.halfVector);\n} <span class=\"hljs-keyword\">else</span> {\n    L = <span class=\"hljs-built_in\">normalize</span>(<span class=\"hljs-type\">vec3</span>(LightSource. position)-Position);\n    <span class=\"hljs-comment\">//Annahme eines infiniten Augenpunkts:</span>\n    <span class=\"hljs-comment\">//somit zeigt der Vektor A zum Augenpunkt immer in z-Richtung </span>\n    <span class=\"hljs-type\">vec4</span> Pos_eye = <span class=\"hljs-type\">vec4</span>(<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">1.0</span>,<span class=\"hljs-number\">0.0</span>); \n    <span class=\"hljs-type\">vec3</span> A = Pos_eye.xyz; \n    H = <span class=\"hljs-built_in\">normalize</span>(L+A); \n    <span class=\"hljs-type\">vec4</span> diffuse = <span class=\"hljs-type\">vec4</span>(<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">1.0</span>); \n    <span class=\"hljs-type\">vec4</span> specular = <span class=\"hljs-type\">vec4</span>(<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">0.0</span>,<span class=\"hljs-number\">1.0</span>); \n    <span class=\"hljs-type\">float</span> diffuseLight = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">dot</span>(N,L),<span class=\"hljs-number\">0.0</span>); \n    <span class=\"hljs-keyword\">if</span>(diffuselight &gt; <span class=\"hljs-number\">0</span>) {\n        diffuse = diffuseLight * Material.diffuse * LightSource.diffuse; \n        <span class=\"hljs-type\">float</span> specLight = <span class=\"hljs-built_in\">pow</span>(<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">dot</span>(H,N),<span class=\"hljs-number\">0</span>), Material.shininess); \n        specular = specLight * Material.specular * LightSource.specular; \n        FragColor = emissiv + ambient + diffuse + specular;\n    }\n}\n</code></pre>\n","position":{"x":850,"y":150},"fontSize":32,"fontColor":"#000000","fontFamily":"Arial, Helvetica, sans-serif","zIndex":1}]}],"title":"Beleuchtung in OpenGL","course":"MDI - Computergrafik 1","chapter":"Beleuchtung und Schattierung","author":"Prof. Allerkamp Dennis","semester":"SoSe21","audio":"65_Beleuchtung_in_OpenGL.mp3","subtitle":""}