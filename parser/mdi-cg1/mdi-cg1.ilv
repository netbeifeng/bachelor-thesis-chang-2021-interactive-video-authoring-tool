{
    /* This ILV is created by cilv tool */
    $title = "Beleuchtung in OpenGL"
    $course = "MDI - Computergrafik 1"
    $chapter = "Beleuchtung und Schattierung"
    $author = "Prof. Allerkamp Dennis"
    $semester = "SoSe21"

    $audio = "C:\\Users\\Chang\\Desktop\\example\\65_Beleuchtung_in_OpenGL.mp3"
    /* $subtitle <"ilv_resources/file.vtt"> optimal */
    /* $font <"ilv_resources/file.ttf">     optimal */

    ^slide = {
        $page = 1           /* the page of this slide */
        $name = "Flat-Shading in OpenGL"    /* the title of this slide */
        $last = (0-206)      /* the first parameter is startTime, the second is the endTime*/
        ^text = {
            $id = 100
            $position = (150, 180)
            /* $last = (0-206) */
            $content = "Im Core-Profile muss jeder Vertex einen Normalenvektor aufweisen falls Normalen gegeben werden<br/> &emsp;‚Ä¢ Grund: VAO-Datenstruktur"
        }

        ^text = {
            $id = 101
            $position = (150, 320)
            /* $last = (10-206) */
            $content = "Auswertung der {#DC3C0B}(Beleuchtung im Vertex-Shader)"
        }

        ^text = {
            $id = 103
            $position = (150, 400)
            /* $last = (30-206) */
            $content = "√úbergabe der Farbwerte mit **`flat out vec4 vColor;`{.glsl}**<br/>&emsp; ‚Ä¢ Rasterizer nimmt {#DC3C0B}(keine Interpolation) vor"
        }

        ^text = {
            $id = 104
            $position = (150, 530)
            /* $last = (40-206) */
            $content = "Im {#DC3C0B}(Fragment-Shader wird nur die Farbe dem Pixel) zugewiesen"
        }

        ^text = {
            $id = 105
            $position = (150, 600)
            /* $last = (50-206) */
            $content = "D.h. jedoch, dass Flat-Shading im Core-Profile trotzdem {#DC3C0B}(f√ºr jeden Vertex eine Beleuchtungsberechnung) durchf√ºhren muss"
        }

        ^quiz = {
            $id = 106
            $position = (200,400)
            $zIndex = 2
            $height = 400
            $width = 300
            $questionContent = "0 = ?"
            $correctAnswer = "0"
            $wrongAnswers = [
                "1",
                "2",
                "3"
            ]
            $tip = "Because 0 = 0"
        }
        /* Here for adding Block Properties */
    }

    ^slide = {
        $page = 2
        $name = "Smooth-Shading in OpenGL"
        $last = (206-250)
        ^text = {
            $id = 200
            $position = (150, 180)
            $last = (206-250)
            $content = "Auswertung der Beleuchtung im Vertex-Shader"
        }

        ^text = {
            $id = 201
            $position = (150, 270)
            $last = (206-250)
            $content = "√úbergabe der Farbwerte mit **`smooth out vec4 vColor;`{.glsl}**<br/> ‚Üí  Rasterizer nimmt Interpolation vor ( {#DC3C0B}(smooth ist default in GLSL) )"
        }

        ^text = {
            $id = 202
            $position = (150, 390)
            $last = (206-250)
            $content = "Im Fragment-Shader nur Zuweisung Farbe -> Pixel"
        }
    }

    ^slide = {
        $page = 3
        $name = "Phong-Shading in OpenGL"
        $last = (250-426)
        ^text = {
            $id = 300
            $position = (150,180)
            $content = "√úbergabe der {#DC3C0B}(transformierten) Normalen und der transformierten Positionen der Vertices vom Vertex-Shader zum Fragment-Shader ({#DC3C0B}(meist in View-Koordinaten))"
        }

        ^text = {
            $id = 301
            $position = (200, 300)
            $content = "```glsl
            smooth out vec3 Normal;
            smooth out vec3 Position;
            ```"
        }

        ^text = {
            $id = 302
            $position = (150,500)
            $content = "Auswertung der Beleuchtung im Fragment-Shader"
        }
    }

    ^slide = {
        $page = 4
        $name = "Beispiel Phong-Shading mit Blinn-Beleuchtung"
        $last = (426-711)
        ^text = {
            $id = 401
            $position = (120, 150) 
            $content = "**Im {#DC3C0B}(Vertex-Shader)**"
        }

        ^text = {
            $id = 402
            $position = (120, 200)
            $content = "
            1. Berechnung von `gl_Position`{.glsl}<br/>
            <span style='font-size: 28px;'>‚Ä¢ built-in variable, die die Vertices aufbereitet f√ºr Clipping, <br/>Culling, etc.</span>
            2. Berechnung der f√ºr die Beleuchtung {#DC3C0B}(im Fragment-<br>Shader notwendigen) Parameter:
            <br/><br/>
            **Position**
            <br/>
            <span style='font-size: 28px;'>&emsp;‚Ä¢ Transformiert jedes Vertex {#DC3C0B}(in View-Space transformiert)</span>
            <br/>
            **Normal**
            <br/>
            <span style='font-size: 28px;'>&emsp;‚Ä¢ Transformiert Normalen mit der Normal-Matrix ({#DC3C0B}(inverse,<br/>
            transponierte 3x3 ModelView-Matrix))</span>
            "
        }

        ^text = {
            $id = 403
            $position = (120, 780)
            $content = "Berechnung der {red}(NormalMatrix au√üerhalb des Shaders):"
        }

        ^text = {
            $id = 404
            $position = (120, 830)
            $content = "```c++
            #include <glm/gtx/inverse_transpose.hpp>
            gl_NormalMatrix =
            glm::inverseTranspose(glm::mat3(gl_ModelViewMatrix));
            ```
            "
        }

        ^text = {
            $id = 405
            $position = (930, 150)
            $content = "```glsl
            //Eingabe-Werte pro Vertex 
            in vec4 vVertex;    //Vertex-Position in Objektkoordinaten
            in vec3 vNormal;    //Normalen-Vektor in Objektkoordinaten
            

            //Uniform-Eingabe-Werte 
            uniform mat4MV;        //ModelView-Matrix 
            uniform mat4MVP;       //ModelViewProjection-Matrix 
            uniform mat3 NormalM;  //Normalen-Matrix
            

            //Ausgabe-Werte smooth 
            out vec3 Position;   //Vertex-Position in Augenpunktskoordinaten  
            out vec3 Normal;     //Normalen-Vektor in Augenpunktskoordinaten 


            void main(void)
            {
                //Vertex aus Objekt-in Projektionskoordinaten 
                gl_Position = MVP * vVertex;
                //Verter aus Objekt-in Augenpunktskoordinaten 
                vec4 Pos = MW * vVertex; 
                Position = Pos.xyz / Pos.w;
                //Vertex-Normale aus Objekt-in Augenpunktskoordinaten 
                Normal = normalize(NormalM * vNormal);
            }
            "
        }
    }
    
    ^slide  = {
        $last = (711-827)
        $page = 5
        $name = "Normal-Matrix"

        ^text = {
            $id = 500
            $position = (150, 180)
            $last = (711-820)
            $content = "Normalen k√∂nnen nicht wie Positionen transformiert werden<br/>
            &emsp;‚Ä¢ {#DC3C0B}(Rotationen) sind kein Problem</br>
            &emsp;‚Ä¢ {#DC3C0B}(Translationen) sind kein Problem, wenn ùë§ = 0 (dann hat die 4. Spalte der Matrix keinen Effekt)<br/>
            &emsp;‚Ä¢ alle anderen Transformationen sind ein Problem"
        }

        ^text = {
            $id = 501
            $position = (150, 430)
            $last = (711-820)
            $content = "Anstelle der Matrix $M$ wird $N = (M^{-1})^{T}$ verwendet<br/>
            &emsp;‚Ä¢ bei Rotationen ist $M^{-1} = M^{T}$"
        }

        ^image = {
            $id = 502
            $last = (711-820)
            $path = "https://i.ibb.co/TrzTc9j/3f82a9a9-2a07-4e37-cebb-8396ab97a04c.png"
            $position = (400, 650)
        }

        ^image = {
            $id = 503
            $last = (711-820)
            $path = "https://i.ibb.co/LJ4bkCJ/d500b649-6d74-41a7-a667-49cb4bb922a6.png"
            $position = (800, 600)
        }

        ^text = {
            $id = 504
            $position = (700,950)
            $last = (711-820)
            $fontSize = 30
            $content = "[http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/](http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/)"
        }

        ^video = {
            $id = 505
            $position = (100,150)
            $last = (821-827)
            $path = "C:\\Users\\Chang\\Desktop\\example\\warum.mp4"
            $width = 1472
            $height = 828
        }
    }

    ^slide = {
        $page = 6
        $name = "Beispiel Phong-Shading mit Blinn-Beleuchtung - 1"
        $last = (828-978)
        ^text = {
            $id = 601
            $position = (150, 180)
            $content = "Im **{#DC3C0B}(Fragment-Shader)**"
        }
        ^text = {
            $id = 602
            $position = (150, 260)
            $content = "{#DC3C0B}(Vertices) mit **Position** und **Normal** 
            <br/>annehmen"
        }

        ^text = {
            $id = 603
            $position = (150, 390)
            $content = "{#DC3C0B}(Parameter der Lichtkomponenten) 
            <br/>entgegennehmen
            <br/>&emsp;‚Ä¢ {#DC3C0B}(Material)-Eigenschaften
            </br>&emsp;‚Ä¢ {#DC3C0B}(Lichtquellen)-Eigenschaften"
        }
        
        ^text = {
            $id = 604
            $position = (150, 640)
            $content = "Berechnung der Fragment-Farbe
            <br/>&emsp;‚Ä¢ FragColor"
        }

        ^text = {
            $id = 605
            $position = (150,770)
            $content = "Bei √§lteren GLSL Versionen<br/>
            auf Uniform-Struct verzichten
            <br/>&emsp;‚Ä¢ Einzelne Uniforms √ºbergeben"
        }

        ^text = {
            $id = 606
            $position = (700, 150)
            $content = "
            ```glsl
            //linear interpolierte Eingabe-Werte pro Fragment 
            in vec3 Position;      //Fragment-Position in 3D 
            in vec3 Normal;        //Normalen-Vektor
            
            //Uniform-Block f√ºr Material-Eigenschaften 
            uniform MaterialParams {
                vec4 emission; 
                vec4 ambient;
                vec4 diffuse; 
                vec4 specular; 
                float shininess; } Material;

            //Uniform-Block fir Lichtquellen-Eigenschaften 
            uniform LightParams {
                vec4 position; 
                vec4 ambient;
                vec4 diffuse; 
                vec4 specular; 
                vec3 halfVector } LightSource;

            //Ausgabe-Wert:Farbe des Fragments 
            out vec4 FragColor;
            ```"
        }
    }

    ^slide = {
        $page = 7
        $name = "Beispiel Phong-Shading mit Blinn-Beleuchtung - 2"
        $last = (978-1779)
        ^text = {
            $id = 701
            $position = (150, 180)
            $last = (978-1200)
            $content = "Im **{#DC3C0B}(Fragment-Shader)**"
        }
        ^text = {
            $id = 702
            $last = (978-1200)
            $position = (150, 260)
            $content = "{#DC3C0B}(Berechnung der Fragment-Farbe) durch die<br/>
            angewandte Beleuchtung"
        }

        ^image = {
            $id = 703
            $position = (30, 420)
            $width = 800
            $last = (978-1200)
            $height = 165
            $path = "https://i.ibb.co/cvfb5Xn/5205afb0-b994-4b0e-85af-1292088003d3.png"
        }

        ^text = {
            $id = 704
            $last = (978-1200)
            $position = (150, 650)
            $content = "GLSL bietet hierf√ºr entsprechende<br/>
            mathematische Funktionen an"
        }

        ^text = {
            $id = 705
            $last = (978-1200)
            $position = (850, 150)
            $content = "```glsl
            void main(void) 
            {
                //Berechnung des Phong-Blinn-Beleuchtungsmodells 
                vec3 N = normalize(Normal); 
                vec4 emissiv = Material.emission; 
                vec4 ambient = Material.ambient * LightSource.ambient; 
                vec3 L = vec3(0.0);    //alle drei Komponenten werden auf 0.0 gesetzt 
                vec3 H = vec3(0.0); 
                if(LightSource.position.w == 0) {
                    L = normalize(vec3(LightSource.position)); 
                    H = normalize(LightSource.halfVector);
                } else {
                    L = normalize(vec3(LightSource. position)-Position);
                    //Annahme eines infiniten Augenpunkts:
                    //somit zeigt der Vektor A zum Augenpunkt immer in z-Richtung 
                    vec4 Pos_eye = vec4(0.0,0.0,1.0,0.0); 
                    vec3 A = Pos_eye.xyz; 
                    H = normalize(L+A); 
                    vec4 diffuse = vec4(0.0,0.0,0.0,1.0); 
                    vec4 specular = vec4(0.0,0.0,0.0,1.0); 
                    float diffuseLight = max(dot(N,L),0.0); 
                    if(diffuselight > 0) {
                        diffuse = diffuseLight * Material.diffuse * LightSource.diffuse; 
                        float specLight = pow(max(dot(H,N),0), Material.shininess); 
                        specular = specLight * Material.specular * LightSource.specular; 
                        FragColor = emissiv + ambient + diffuse + specular;
                    }
            }
            ```"
        }

        ^custom = {
            $id = 706
            $path = "C:\\Users\\Chang\\Desktop\\example\\teapot.html"
            $position = (50,180)
            $last = (1200-1779)
            $zIndex = 5
        }

        ^custom = {
            $id = 707
            $path = "C:\\Users\\Chang\\Desktop\\example\\test.js"
            $last = (978-1200)
        }

        ^custom = {
            $id = 708
            $position = (1050,150)
            $path = "C:\\Users\\Chang\\Desktop\\example\\editor.html"
            $last = (1200-1779)
            $zIndex = 5
        }
    }
}